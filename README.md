# leetcode-solutions-kotlin
These are my solutions to the leetcode problems that I've been solving for practice

## Patterns

- Sliding Window
  - arrays, lists, strings
  - must scan through subarray or substring
  - when the array must satisfy some condition (shortest/longest/min/max)

- Two pointers
  - Linear data structures (arrays, lists, strings)
  - when you need to scan start and end of a list
  - when you have a sorted list and need to find pairs
  - removing duplicates or filtering

- Slow & fast pointers
  - Linear data structures (arrays, lists, strings)
  - detect cycle in linked list
  - find middle of linked list

- Linked list reversal
  - reverse a linked list in 1 pass and O(1) space
  - reverse specific portion of a linked list
  - reverse nodes in groups of k

- Binary search
  - input is sorted and need to find a number
  - finding the position of insertion in a sorted list
  - handling duplicates in sorted arrays
  - searching in rotated sorted arrays

- Top K elements
  - find the top k smallest or largest elements
  - find the kth smallest or largest element
  - find the k most frequent elements

- Binary tree traversal
  - preorder: nlr
  - inorder: lnr
  - postorder: lrn
  - bfs: by level

- Graph traversal
  - dfs
  - bfs
  - topological sort

- Backtracking
  - combinatorial problems (combinations, permutations, subsets)
  - constraint satisfaction (sudoku, n-queens)
  - prune paths using constraints to reduce search space

- Dynamic programming
  - used when you need to solve a problem that depends on previous results from subproblems
  - overlapping subproblems and optimal substructure
  - optimization problems (min/max distance, profit)
  - sequence problems (longest increasing subsequence)
  - combinatorial problems (number of ways to do something)
  - reduce time complexity from exponential to polynomial

- Bit manipulation
  - count number of 0 or 1s in a number
  - add numbers without using addition or subtraction
  - find a missing number in a list

- Overlapping intervals
  - merge or consolidate ranges
  - schedule or find conflicts
  - find gaps or missing intervals

- Monotonic stack
  - find next greater or smaller element
  - find left/right boundary points in histograms or rectangles
  - maintain elements in order to optimize operations

- Prefix Sum
  - cumulative sums are needed from index 0 to any element
  - querying subarray sums frequently accross multiple ranges
  - partial sums can be reused efficiently